<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>90's Trippy Fractal Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #0f0;
            text-align: center;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #title {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            font-size: 24px;
            text-shadow: 0 0 10px #0f0;
            z-index: 10;
            animation: pulse 2s infinite;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            font-size: 14px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        .scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                to bottom,
                rgba(0, 0, 0, 0.05) 0px,
                rgba(0, 0, 0, 0.05) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="title">90'S FRACTAL TRIPPY DEMO</div>
        <canvas id="canvas"></canvas>
        <div class="scanline"></div>
        <div id="info">Bouncing Emojis | Fractal Zoom | Retro Graphics</div>
    </div>

    <script>
        // Get canvas and context
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full window size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Fractal parameters
        let time = 0;
        let zoom = 1;
        let zoomSpeed = 0.02;
        let rotation = 0;
        let rotationSpeed = 0.005;
        
        // Emoji array
        const emojis = ['ğŸ˜€', 'ğŸ˜‚', 'ğŸ˜', 'ğŸ¤©', 'ğŸ˜', 'ğŸ¥³', 'ğŸ¤ª', 'ğŸ˜œ', 'ğŸ˜‡', 'ğŸ¥º', 'ğŸ¤¯', 'ğŸ¥¶', 'ğŸ¤ ', 'ğŸ‘»', 'ğŸ‘¾', 'ğŸ¤–', 'ğŸ‘½', 'ğŸ’©', 'ğŸ‘¾', 'ğŸ¶', 'ğŸ±', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ®', 'ğŸ·', 'ğŸ¸', 'ğŸµ', 'ğŸ”', 'ğŸ§', 'ğŸ¦', 'ğŸ¦†', 'ğŸ¦…', 'ğŸ¦‰', 'ğŸ¦‡', 'ğŸº', 'ğŸ—', 'ğŸ´', 'ğŸ¦„', 'ğŸ', 'ğŸ›', 'ğŸ¦‹', 'ğŸŒ', 'ğŸ', 'ğŸœ', 'ğŸ¦Ÿ', 'ğŸ¦—', 'ğŸ•·', 'ğŸ¦‚', 'ğŸ¢', 'ğŸ', 'ğŸ¦', 'ğŸ¦–', 'ğŸ¦•', 'ğŸ™', 'ğŸ¦‘', 'ğŸ¦', 'ğŸ¦', 'ğŸ¦€', 'ğŸ¡', 'ğŸ ', 'ğŸŸ', 'ğŸ¬', 'ğŸ³', 'ğŸ‹', 'ğŸ¦ˆ', 'ğŸŠ', 'ğŸ…', 'ğŸ†', 'ğŸ¦“', 'ğŸ¦', 'ğŸ¦§', 'ğŸ˜', 'ğŸ¦›', 'ğŸ¦', 'ğŸª', 'ğŸ«', 'ğŸ¦’', 'ğŸ¦˜', 'ğŸƒ', 'ğŸ‚', 'ğŸ„', 'ğŸ', 'ğŸ–', 'ğŸ', 'ğŸ‘', 'ğŸ¦™', 'ğŸ', 'ğŸ¦Œ', 'ğŸ•', 'ğŸ©', 'ğŸ¦®', 'ğŸ•â€ğŸ¦º', 'ğŸˆ', 'ğŸˆâ€â¬›', 'ğŸ“', 'ğŸ¦ƒ', 'ğŸ¦š', 'ğŸ¦œ', 'ğŸ¦¢', 'ğŸ¦©', 'ğŸ•Š', 'ğŸ‡', 'ğŸ¦', 'ğŸ¦¨', 'ğŸ¦¡', 'ğŸ¦«', 'ğŸ¦¦', 'ğŸ¦¥', 'ğŸ', 'ğŸ€', 'ğŸ¿', 'ğŸ¦”'];
        
        // Emoji objects
        const emojiObjects = [];
        const emojiCount = 30;
        
        // Create emoji objects
        for (let i = 0; i < emojiCount; i++) {
            emojiObjects.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 30 + 10,
                speedX: (Math.random() - 0.5) * 4,
                speedY: (Math.random() - 0.5) * 4,
                emoji: emojis[Math.floor(Math.random() * emojis.length)],
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.1
            });
        }
        
        // Fractal rendering function
        function renderFractal() {
            // Clear canvas with a semi-transparent black for trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update time and zoom
            time += 0.01;
            zoom += zoomSpeed;
            
            // Reverse zoom direction at certain points
            if (zoom > 10 || zoom < 0.1) {
                zoomSpeed *= -1;
            }
            
            // Update rotation
            rotation += rotationSpeed;
            
            // Draw fractal pattern
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(canvas.width, canvas.height) * 0.4;
            
            // Draw multiple layers of fractals
            for (let layer = 0; layer < 5; layer++) {
                const radius = maxRadius * (0.8 - layer * 0.1);
                const angleOffset = time * (0.5 + layer * 0.1);
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = `hsl(${(time * 20 + layer * 30) % 360}, 100%, 50%)`;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw connecting lines
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2 + angleOffset;
                    const x1 = centerX + Math.cos(angle) * radius;
                    const y1 = centerY + Math.sin(angle) * radius;
                    const x2 = centerX + Math.cos(angle + Math.PI) * radius;
                    const y2 = centerY + Math.sin(angle + Math.PI) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = `hsl(${(time * 20 + layer * 30 + i * 30) % 360}, 100%, 50%)`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
            
            // Draw fractal tree
            drawFractalTree(centerX, centerY, 100, -Math.PI/2, time * 0.5);
            
            // Draw rotating pattern
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(rotation);
            
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const x = Math.cos(angle) * 150;
                const y = Math.sin(angle) * 150;
                const size = 10 + Math.sin(time + i) * 5;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${(time * 20 + i * 18) % 360}, 100%, 50%, 0.7)`;
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // Recursive fractal tree function
        function drawFractalTree(x, y, size, angle, time) {
            if (size < 2) return;
            
            const endX = x + Math.cos(angle) * size;
            const endY = y + Math.sin(angle) * size;
            
            // Draw branch
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = `hsl(${(time * 10) % 360}, 100%, 50%)`;
            ctx.lineWidth = size / 10;
            ctx.stroke();
            
            // Draw smaller branches
            const newSize = size * 0.7;
            const angleOffset = time * 0.2;
            
            drawFractalTree(endX, endY, newSize, angle - 0.5 + Math.sin(time) * 0.3, time);
            drawFractalTree(endX, endY, newSize, angle + 0.5 + Math.sin(time) * 0.3, time);
            drawFractalTree(endX, endY, newSize, angle + Math.sin(time * 0.7) * 0.5, time);
        }
        
        // Draw bouncing emojis
        function drawEmojis() {
            emojiObjects.forEach(emoji => {
                // Update position
                emoji.x += emoji.speedX;
                emoji.y += emoji.speedY;
                emoji.rotation += emoji.rotationSpeed;
                
                // Bounce off edges
                if (emoji.x < 0 || emoji.x > canvas.width) {
                    emoji.speedX *= -1;
                    emoji.x = emoji.x < 0 ? 0 : canvas.width;
                }
                
                if (emoji.y < 0 || emoji.y > canvas.height) {
                    emoji.speedY *= -1;
                    emoji.y = emoji.y < 0 ? 0 : canvas.height;
                }
                
                // Draw emoji with rotation
                ctx.save();
                ctx.translate(emoji.x, emoji.y);
                ctx.rotate(emoji.rotation);
                ctx.font = `${emoji.size}px Arial`;
                ctx.fillText(emoji.emoji, -emoji.size/2, emoji.size/2);
                ctx.restore();
            });
        }
        
        // Main animation loop
        function animate() {
            renderFractal();
            drawEmojis();
            requestAnimationFrame(animate);
        }
        
        // Start animation
        animate();
        
        // Add some retro effects
        setInterval(() => {
            // Random screen flicker
            if (Math.random() < 0.05) {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.1})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Change emoji colors occasionally
            if (Math.random() < 0.02) {
                emojiObjects.forEach(emoji => {
                    emoji.emoji = emojis[Math.floor(Math.random() * emojis.length)];
                });
            }
        }, 100);
    </script>
</body>
</html>
