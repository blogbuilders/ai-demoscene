<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>90s Graphics Demo</title>
<style>
  html,body { height:100%; margin:0; background:#000; overflow:hidden; font-family:monospace; }
  #container { position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
  canvas { image-rendering: pixelated; display:block; }
  #ui {
    position:absolute; left:12px; top:12px; color:#0f0; background:rgba(0,0,0,0.35);
    padding:8px 10px; border:1px solid rgba(255,255,255,0.06); border-radius:6px;
    font-size:13px; backdrop-filter: blur(2px);
  }
  #ui b { color:#ff6; }
  .hint { color:#9f9; font-size:12px; margin-top:6px; display:block; }
</style>
</head>
<body>
<div id="container">
  <canvas id="screen"></canvas>
  <div id="ui">
    <div><b>90s Demo</b> â€” fractal zoom + low rez emojis</div>
    <div class="hint">Press Space to pause; Click to randomize palette</div>
  </div>
</div>

<script>
/* 90s Style Graphics Demo
   - Mandelbrot fractal zoom with palette cycling
   - Low-resolution emoji sprites drawn to offscreen canvas and scaled up
   - CRT scanlines, vignette, and color shift for retro feel
   - Single-file, pure HTML + JS
*/

const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d', { alpha: false });

let W = canvas.width = Math.floor(window.innerWidth);
let H = canvas.height = Math.floor(window.innerHeight);

window.addEventListener('resize', () => {
  W = canvas.width = Math.floor(window.innerWidth);
  H = canvas.height = Math.floor(window.innerHeight);
  pixelBuffer = new Uint8ClampedArray(W * H * 4);
  offscreen.width = Math.max(160, Math.floor(W/4));
  offscreen.height = Math.max(120, Math.floor(H/4));
});

// Offscreen low-res canvas for pixelation
const offscreen = document.createElement('canvas');
offscreen.width = Math.max(160, Math.floor(W/4));
offscreen.height = Math.max(120, Math.floor(H/4));
const offCtx = offscreen.getContext('2d', { alpha: false });

// Pixel buffer for fractal
let pixelBuffer = new Uint8ClampedArray(W * H * 4);

// Palette utilities
function makePalette(type=0) {
  const pal = [];
  for (let i=0;i<256;i++){
    const t = i/255;
    if (type===0) {
      // neon rainbow
      pal.push([Math.floor(128+127*Math.sin(3.0*t+0.0)),
                Math.floor(128+127*Math.sin(3.0*t+2.0)),
                Math.floor(128+127*Math.sin(3.0*t+4.0))]);
    } else if (type===1) {
      // teal-magenta
      pal.push([Math.floor(32+200*Math.pow(t,0.6)),
                Math.floor(8+120*Math.pow(1-t,1.2)),
                Math.floor(80+160*Math.pow(t,0.9))]);
    } else {
      // fire
      pal.push([Math.floor(255*Math.pow(t,0.5)),
                Math.floor(80*Math.pow(t,1.2)),
                Math.floor(20*Math.pow(t,2.0))]);
    }
  }
  return pal;
}

let palette = makePalette(0);
let paletteIndex = 0;

// Fractal parameters
let cx = -0.743643887037151; // interesting center
let cy = 0.13182590420533;
let scale = 0.0025; // smaller = zoomed in
let zoomSpeed = 0.985; // per frame multiplier
let maxIterBase = 80;
let paused = false;
let frame = 0;

// Emoji sprites
const emojis = ['ðŸ˜€','ðŸ˜Ž','ðŸ’¾','ðŸŽ§','ðŸŒˆ','ðŸ”¥','âœ¨','ðŸŒ€','ðŸ’€','ðŸ‘¾'];
const sprites = [];
const spriteCount = 18;
const spriteLowRes = 12; // pixel size for low-res emoji
const spriteCanvas = document.createElement('canvas');
spriteCanvas.width = spriteCanvas.height = spriteLowRes;
const spriteCtx = spriteCanvas.getContext('2d');

// Create low-res emoji images
function createEmojiImage(ch, colorize=false) {
  const s = spriteLowRes;
  spriteCtx.clearRect(0,0,s,s);
  spriteCtx.fillStyle = '#000';
  spriteCtx.fillRect(0,0,s,s);
  spriteCtx.font = (s-2) + 'px serif';
  spriteCtx.textAlign = 'center';
  spriteCtx.textBaseline = 'middle';
  spriteCtx.fillStyle = '#fff';
  spriteCtx.fillText(ch, s/2, s/2+1);
  // pixelate by sampling
  const img = new Image();
  img.src = spriteCanvas.toDataURL();
  return img;
}

for (let i=0;i<spriteCount;i++){
  sprites.push({
    img: createEmojiImage(emojis[i % emojis.length]),
    x: Math.random() * W,
    y: Math.random() * H,
    vx: (Math.random()*2-1) * (1 + Math.random()*3),
    vy: (Math.random()*2-1) * (1 + Math.random()*3),
    size: 18 + Math.floor(Math.random()*28),
    wob: Math.random()*0.02 + 0.01
  });
}

// Utility: draw pixelated image scaled up with nearest neighbor
function drawPixelatedImage(img, dx, dy, dw, dh) {
  // draw small image into offCtx then scale up to main ctx with pixelated rendering
  offCtx.imageSmoothingEnabled = false;
  // draw background for transparency
  offCtx.fillStyle = '#000';
  offCtx.fillRect(0,0,offscreen.width,offscreen.height);
  // compute small draw size
  const smallW = Math.max(8, Math.floor(dw / 8));
  const smallH = Math.max(8, Math.floor(dh / 8));
  offCtx.drawImage(img, 0, 0, img.width, img.height, 0, 0, smallW, smallH);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(offscreen, 0, 0, smallW, smallH, dx, dy, dw, dh);
}

// Mandelbrot rendering into ImageData
function renderFractalToBuffer(width, height, centerX, centerY, scaleVal, maxIter, pal, timeOffset=0) {
  const invW = 1/width;
  const invH = 1/height;
  const halfW = width/2;
  const halfH = height/2;
  let idx = 0;
  for (let y=0;y<height;y++){
    const cy = centerY + (y - halfH) * scaleVal;
    for (let x=0;x<width;x++){
      const cx = centerX + (x - halfW) * scaleVal;
      let zx = 0, zy = 0, zx2 = 0, zy2 = 0;
      let iter = 0;
      while (zx2 + zy2 <= 4 && iter < maxIter) {
        zy = 2*zx*zy + cy;
        zx = zx2 - zy2 + cx;
        zx2 = zx*zx;
        zy2 = zy*zy;
        iter++;
      }
      let color;
      if (iter === maxIter) {
        color = [0,0,0];
      } else {
        // smooth coloring
        const mu = iter + 1 - Math.log(Math.log(Math.sqrt(zx2+zy2)))/Math.log(2);
        const t = Math.max(0, Math.min(255, Math.floor((mu/maxIter)*255)));
        // palette cycling by timeOffset
        const idxPal = (t + Math.floor(timeOffset)) & 255;
        color = pal[idxPal];
      }
      pixelBuffer[idx++] = color[0];
      pixelBuffer[idx++] = color[1];
      pixelBuffer[idx++] = color[2];
      pixelBuffer[idx++] = 255;
    }
  }
}

// Retro post processing: scanlines and vignette
function postProcess(imageData, width, height, t) {
  const data = imageData.data;
  for (let y=0;y<height;y++){
    const scan = (Math.sin((y + t*0.6) * 0.12) * 0.5 + 0.5) * 0.12; // scanline darkness
    const vy = 1 - Math.abs((y - height/2)/(height/2));
    const vign = Math.pow(vy, 1.6) * 0.9 + 0.1;
    for (let x=0;x<width;x++){
      const i = (y*width + x) * 4;
      // slight chromatic aberration by offsetting channels
      const r = data[i], g = data[i+1], b = data[i+2];
      // apply scanline and vignette
      data[i]   = Math.max(0, Math.min(255, (r * (1 - scan) * vign)));
      data[i+1] = Math.max(0, Math.min(255, (g * (1 - scan*0.9) * vign)));
      data[i+2] = Math.max(0, Math.min(255, (b * (1 - scan*1.1) * vign)));
    }
  }
}

// Main animation loop
let last = performance.now();
function loop(now) {
  const dt = Math.min(40, now - last);
  last = now;
  if (!paused) {
    frame++;
    // zoom and slowly drift center
    scale *= Math.pow(zoomSpeed, dt/16.67);
    cx += Math.sin(frame*0.0013) * 0.0000008 * dt;
    cy += Math.cos(frame*0.0011) * 0.0000008 * dt;
  }

  // compute dynamic max iterations for detail
  const maxIter = Math.floor(maxIterBase + Math.log(1/scale) * 6);

  // render fractal into buffer
  renderFractalToBuffer(W, H, cx, cy, scale, maxIter, palette, frame*0.6);

  // put buffer into ImageData and postprocess
  const imgData = new ImageData(new Uint8ClampedArray(pixelBuffer), W, H);
  postProcess(imgData, W, H, frame*0.5);

  // draw fractal to canvas
  ctx.putImageData(imgData, 0, 0);

  // overlay low-res emoji sprites
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (let s of sprites) {
    // update physics
    if (!paused) {
      s.x += s.vx * (dt/16.67);
      s.y += s.vy * (dt/16.67);
      // wobble
      s.vx += Math.sin((frame + s.x) * s.wob) * 0.02;
      s.vy += Math.cos((frame + s.y) * s.wob) * 0.02;
    }
    // bounce
    if (s.x < -s.size) { s.x = -s.size; s.vx *= -1; }
    if (s.x > W + s.size) { s.x = W + s.size; s.vx *= -1; }
    if (s.y < -s.size) { s.y = -s.size; s.vy *= -1; }
    if (s.y > H + s.size) { s.y = H + s.size; s.vy *= -1; }

    // draw pixelated emoji by drawing small then scaling up
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    // draw emoji to small offscreen and scale up
    const small = Math.max(8, Math.floor(s.size / 6));
    offCtx.clearRect(0,0,offscreen.width,offscreen.height);
    offCtx.fillStyle = 'rgba(0,0,0,0)';
    offCtx.fillRect(0,0,small,small);
    offCtx.font = (small-1) + 'px serif';
    offCtx.textAlign = 'center';
    offCtx.textBaseline = 'middle';
    offCtx.fillStyle = '#fff';
    offCtx.fillText(s.img ? '' : '', small/2, small/2);
    // Instead of using s.img (which is a dataURL), draw emoji directly to offscreen for crisp low-res
    offCtx.clearRect(0,0,small,small);
    offCtx.fillStyle = '#000';
    offCtx.fillRect(0,0,small,small);
    offCtx.font = (small-1) + 'px serif';
    offCtx.fillStyle = '#fff';
    offCtx.fillText(emojis[Math.floor(Math.abs(s.x+s.y)) % emojis.length], small/2, small/2+1);

    ctx.drawImage(offscreen, 0, 0, small, small, s.x - s.size/2, s.y - s.size/2, s.size, s.size);
    ctx.restore();
  }
  ctx.restore();

  // CRT overlay: subtle scanlines and vignette using blend
  ctx.save();
  ctx.globalCompositeOperation = 'overlay';
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, 'rgba(255,255,255,0.02)');
  g.addColorStop(0.5, 'rgba(0,0,0,0.06)');
  g.addColorStop(1, 'rgba(255,255,255,0.02)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // scanlines
  ctx.globalCompositeOperation = 'multiply';
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  for (let y=0;y<H;y+=2) {
    ctx.fillRect(0,y,W,1);
  }
  ctx.restore();

  // subtle color shift chroma
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  ctx.fillStyle = 'rgba(10,0,30,0.02)';
  ctx.fillRect(0,0,W,H);
  ctx.restore();

  // small HUD text
  ctx.save();
  ctx.fillStyle = '#0f0';
  ctx.font = '12px monospace';
  ctx.fillText('Frame: ' + frame + '  Scale: ' + scale.toExponential(2) + '  Iter: ' + maxIter, 12, H - 12);
  ctx.restore();

  requestAnimationFrame(loop);
}

// Input handlers
window.addEventListener('keydown', (e) => {
  if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
  if (e.code === 'KeyR') { randomize(); }
});

canvas.addEventListener('click', () => {
  randomize();
});

function randomize() {
  // randomize palette and center a bit
  paletteIndex = (paletteIndex + 1) % 3;
  palette = makePalette(paletteIndex);
  cx += (Math.random()-0.5) * 0.01;
  cy += (Math.random()-0.5) * 0.01;
  scale *= 0.6 + Math.random()*0.8;
  for (let s of sprites) {
    s.vx = (Math.random()*2-1) * (1 + Math.random()*3);
    s.vy = (Math.random()*2-1) * (1 + Math.random()*3);
  }
}

// initialize and start
pixelBuffer = new Uint8ClampedArray(W * H * 4);
requestAnimationFrame(loop);
</script>
</body>
</html>